% !TEX root =  master.tex
\chapter{Lineare fehlerkorrigierende Codes für kryptographische Zwecke}
Mithilfe der vorgestellten Polynome soll nun eine Klasse von Blockcodes betrachtet werden, zu der auch \textit{Reed-Solomon}-Codes und \textit{Goppa}-Codes, die beiden Codes aus den Verfahren von \textsc{Niederreiter} und \textsc{McEliece}, zählen. Diese Klasse wird als \textbf{lineare Codes} bezeichnet. \\\\
Für die Definition linearer Codes ist eine Wiederholung der algebraischen Struktur des \textbf{Vektorraums} notwendig. In \parencite{Fischer2020LA} ist folgende Definition zu finden:
\begin{definition}
Sei $K$ ein Körper. Eine Menge $V$ mit einer additiven Verknüpfung 
\[+ \colon V \times V \to V; \quad \langle v, w \rangle \mapsto v + w\]
und einer Skalarmultiplikation 
\[\circ \colon K \times V \to V; \quad \langle \lambda, v \rangle \mapsto \lambda \circ v\]
heißt \textbf{$K$-Vektorraum}, sofern gilt:
\begin{itemize}
\item $(V, +)$ ist \textbf{abelsche Gruppe}.
\item Die Skalarmultiplikation ist sowohl bezüglich des Skalars als auch der Komponente distributiv und assoziativ, ferner ist das Element $1 \in K$ das neutrale Element für diese Skalarmultiplikation. So muss $\forall \lambda, \mu \in K;\, v, w \in V$ gelten:
\begin{align*}
( \lambda + \mu ) \circ v &= \lambda \circ v + \mu \circ v \\
\lambda \circ (v + w) &= \lambda \circ v + \lambda \circ w \\
\lambda \circ (\mu \circ v) &= (\lambda \circ \mu ) \circ v \\
1 \circ v &= v
\end{align*}
\end{itemize}
\parencite[vgl.][S. 95]{Fischer2020LA}
\end{definition}
Vektorräume können mit einer beliebigen Dimension konstruiert werden und beinhalten folglich Vektoren dieser Dimension, deren Komponenten addiert und mit Skalaren multipliziert werden können. Für die Definition linearer Codes ist es erforderlich, Vektorräume $\mathbb{F}_{q}^{n}$ auf Primzahlkörpern $\mathbb{F}_{q}$ zu definieren.
\begin{theorem}
Endliche Körper $\mathbb{F}_{q}$ bilden $\mathbb{F}_{q}^{n}$-Vektorräume.
\end{theorem}
\begin{proof}
Es bietet sich an, induktiv vorzugehen:
\begin{itemize}
\item \textbf{Annahme}: $\mathbb{F}_{q}^{n}$ bildet einen Vektorraum $V(q, n)$.
\item \textbf{Induktionsanfang}: Zu zeigen ist, dass $\mathbb{F}_{q}^{1}$ die Forderungen eines Vektorraums erfüllt.
\begin{itemize}
\item Die Forderung danach, dass $(\mathbb{F}_{q}, +)$ eine abelsche Gruppe bildet, folgt unmittelbar aus der Körperdefinition.
\item Die Forderungen nach Distributivität und Assoziativität der Skalarmultiplikation bzw. Addition folgen direkt aus der Ringeigenschaft, da $\lambda, \mu, v \in \mathbb{F}_{q}^{1}$.
\item Die Existenz eines neutralen Elements bezüglich der Skalarmultiplikation ergibt sich daraus, dass gemäß Definition $q \geq 2 > 1 \Rightarrow 1 \in \mathbb{F_q}$ gilt. 
\end{itemize}
\item \textbf{Induktionsschritt $1 \to n$}: Sei die komponentenweise Addition induktiv definiert als \[(v_1, v_2, ..., v_n) + (w_1, w_2, ..., w_n) = (v_1 + w_1, v_2 + w_2, ..., v_n + w_n)\] und die Skalarmultiplikation als
\[k \circ (v_1, v_2, ..., v_n) = (k\circ v_1, k \circ v_2, ..., k \circ v_n)\].
Alle obigen Forderungen folgen damit induktiv und $\mathbb{F}_{q}^{n}$ ist ein $\mathbb{F}_q$-Vektorraum.
\end{itemize}
\end{proof}
\begin{definition}
Ein \textbf{Untervektorraum} $W$ eines Vektorraums $V$ ist eine Teilmenge $W \subset V$, für die gilt:
\begin{itemize}
\item $W \neq \emptyset$
\item $v, w \in W: \quad v + w \in W$
\item $v \in W, \lambda \in K: \quad \lambda \circ v \in W$ 
\end{itemize}
\parencite[vgl. ][S. 96]{Fischer2020LA}
\end{definition}
\begin{definition}
Sei $\mathbb{F}_q$ ein endlicher Körper, $\lvert K \rvert = q$. Dann ist ein Blockcode $C$ ein \textbf{linearer Code} mit dem Alphabet $\mathbb{F}_q$ und Länge $n$, falls die Menge $C$ ein \textbf{Untervektorraum} von $\mathbb{F}_{q}^{n}$ ist \parencite[vgl. ][S. 29]{Manz2017}. 
\end{definition}
Folglich beschreibt ein linearer Code Tupel der Länge $n$ mit Komponenten aus $\mathbb{F}_q$. Ferner stellt die Untervektorraum-Eigenschaft sicher, dass die Addition von Codeworten und die Multiplikation eines Codewortes mit einem Skalar aus dem übergeordneten endlichen Körper $\mathbb{F}_q$ weiterhin valide Codeworte erzeugt. Dies ist eine elementare Eigenschaft linearer Codes.
\\\\
Eine Subklasse der linearen Codes sind die \textbf{zyklischen Codes}. 
\section{Zyklische Codes}
\begin{definition}
Ein $k$-dimensionaler Untervektorraum $C$ von $\mathbb{F}_{q}^{n}$ ist dann ein \textbf{zyklischer Code}, wenn
\[\forall \, \langle a_0, a_1, ..., a_{n-1} \rangle \in C: \quad \langle a_{n-1}, a_0, a_1, ..., a_{n-2} \rangle \in C\] gilt \parencite[vgl. ][S. 42]{vanLint1973}.
\end{definition}
Ein linearer Code ist folglich dann zyklisch, falls zu jedem Codewort auch das Codewort Teil des Codes ist, das durch eine zyklische Verschiebung entsteht. Ein solcher Code ist beispielsweise der \textit{gewöhnliche Reed-Colomon-Code}, der neben der verallgemeinerten, nicht zyklischen Version Gegenstand des nächsten Abschnitts ist.
\begin{theorem}
Zyklische Codes der Länge $n$ sind Ideale des Rings $R = \mathbb{F}_{q}[x]/(x^n -1)$.
\end{theorem}
Das Polynom $x^n - 1$ fungiert hierbei als Modul, sodass der Ring $R$ folglich die Restklassen bezüglich dieser modularen Reduktion von $\mathbb{F}_{q}$ enthält.
\begin{note}
Sei $C$ ein linearer zyklischer Code der Länge $n$ über einem Körper $F_{q}$ und $a = a(x) = a_0 + a_{1}\cdot x + ... + a_{n-1}\cdot x^{n-1} \in C$. Dann ist 
\begin{align*}
&x \cdot a \\
& = x \cdot (a_0 + a_{1} \cdot x + ... + a_{n-1}\cdot x^{n-1}) \\
& = a_0 \cdot x + a_{1} \cdot x^2 + ... + a_{n-1} \cdot x^n  \\
& = a_{n-1} + a_{0}\cdot x + ... + a_{n-2} \cdot x^{n-1}
\end{align*}
genau das zyklisch verschobene Codewort $a' \in C$. \\
Dies folgt aus $x^n \equiv 1 \mod x^n - 1$ \parencite[vgl. ][S. 149f.]{Biggs08}.
\end{note}
Da durch die Linearität des Codes $C$ lässt sich ein $a \in C$ nicht nur beliebig oft zyklisch verschieben, also mit $x$ multiplizieren, sondern auch lineare Kombinationen (also Summen) gültiger Codeworte ergeben wiederum ein gültiges Codewort in $C$. Somit ergibt auch das Produkt eines Codewortes mit einem Polynom, also 
\[a(x) \cdot c(x) \in C, \, c(x) \in C,\, a \in \mathbb{F}_{q}[x]/(x^n - 1)\] 
ein gültiges Codewort \parencite[vgl. ][S. 121]{Moon05}. \\\\
Da Ideale eines Polynomrings erzeugende Polynome besitzen, ist die Angabe eines \textbf{Generatorpolynoms} $g(x)$ möglich, für das gilt:
\begin{itemize}
\item $\deg g(x) = n - k$
\item $g(x) \mid (x^n - 1)$
\end{itemize} 
\begin{theorem}
Sei $C$ ein linearer zyklischer Code über einem endlichen Körper $\mathbb{F}_{q}$. Dann gibt es ein Polynom $g(x)$, für das $C = \langle g(x) \rangle$ gilt.
\end{theorem}
Ein Codewort beziehungsweise ein Codewortpolynom $c(x)$ eines linearen, zyklischen Codes mit Generatorpolynom $g(x)$ kann nun als Produkt von Nachrichtpolynom $m(x)$ und Generatorpolynom aufgefasst werden \parencite[vgl. ][S. 121]{Moon05}.
\[c(x) = m(x) \cdot g(x)\]
Bei vielen aktuellen Anwendungen von \textit{Reed-Solomon-Codes} werden Generatorpolynome angegeben und genutzt \parencite[vgl. ][S. 6]{WBC11994}.
\section{Definition der Klasse von Reed-Solomon-Codes}
Die grundlegende Idee von linearen (zyklischen) Codes über Polynomen besteht darin, Fehler über Interpolation zu korrigieren. Bildlich gesehen soll also ein Codewort konstruiert werden, dessen einzelnen Komponenten entlang einer interpolierbaren Abbildung aufgereiht sind. Sollte nun ein Übertragungsfehler die Lage eines Punktes (also einer Komponente) verändern, so ist die korrekte Lage durch die anderen Punkte jedoch hinreichend bestimmt und kann korrigiert werden.
\paragraph{Idee}
Eine Nachricht der Länge $k$ in Form eines Elementes eines endlichen Körpers $\mathbb{F}_{q}^{k}$ kann als Polynom aufgefasst werden, indem die entsprechenden Komponenten der Nachricht die Koeffizienten des Polynoms bilden. Werden nun $n$ paarweise verschiedene Stützstellen aus dem dem Code zugrundeliegenden Körper $\mathbb{F}_{q}^{n}$ ausgewählt, so ergibt die Auswertung des Polynoms an den jeweiligen Stützstellen die Komponenten eines betrachteten Codewortes. \\\\
Durch bereits $k$ Komponenten des Codewortes ist das Polynom hinreichend bestimmt, sodass $n-k$ Punkte, die während der Übertragung ausgelöscht wurden, und $(n-k)/2$ verfläscht übertragene Punkte als Fehler erkannt und korrigiert werden können.
\begin{definition}
Sei $u = \langle u_1, u_2, ..., u_n \rangle \in \mathbb{F}_{q}^{n}$, wobei $\forall i, j \in \lbrace 1, ..., n \rbrace : u_i \neq u_j$. Dann ist $a = \langle a_1, a_2, ..., a_n \rangle \in \mathbb{F}_{q}^{n}$ ein Codewort eines \textbf{Reed-Solomon-Codes} $C$ mit Länge $n$, Dimension $k$ und Minimaldistanz $d$, falls es ein Polynom $f(x)$ mit Grad $\deg f < k$ gibt, sodass $f(u_i) = a_i$ ist. Die Menge aller dieser Codeworte $a$ ist $C$:
\[C = \lbrace a \mid a_i = f(u_i), \deg f(x) < k, f \in \mathbb{F}_{q}^{n}[x] \rbrace\]
\parencite[vgl. ][S. 9]{Mahr88}
\end{definition}
\begin{example}
Sei $m = \langle 0, 1, 2, 1 \rangle \in \mathbb{F}_{7}^{4}$. Dann ist $m(X) = 0 + 1 \circ X + 2 \circ X^2 + 1 \circ X^3 \in \mathbb{F}_{7}[X]$ die polynomielle Darstellung dieser Nachricht $m$. \\\\
Betrachtet werde nun ein \textbf{Reed-Solomon-Code} $C$ mit Länge $n = 7$ und Dimension $k = 4$:
\[C = \lbrace a \mid a_i = f(u_i), \deg f(x) < 4, f \in \mathbb{F}_{7}^{7}[x]\rbrace\]
\begin{itemize}
\item Gewählt sind folglich $n$ paarweise verschiedene Stützstellen, deren Wahlfreiheit in $\mathbb{F}_7$ lediglich in der Anordnung besteht. Möglich ist beispielsweise $u = \langle 0, 1, 2, 3, 4, 5, 6 \rangle \in \mathbb{F}_{7}^{7}$.
\item Auswertung:
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
Stützstelle $u_i$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
\hline
Auswertung $m(u_i)$& 0 & 4 & 4 & 6 & 2 & 5 & 0 \\ 
\hline
\end{tabular}
\item Folglich ergibt sich das Codewort $c = \langle 0, 4, 4, 6, 2, 5, 0 \rangle \in \mathbb{F}_{7}^{7}$.
\end{itemize}
\end{example}
\begin{note}
Das Generatorpolynom zu einem \textit{Reed-Solomon-Code} ist definiert durch
\[g(x) = \prod_{j = 1}^{2t} (x - \alpha^{j})\]
wobei $t$ die Anzahl der durch diesen Code korrigierbaren Fehler und $\alpha$ ein primitives Element des zugrundeliegenden Körpers repräsentiert, es gilt $n - k = 2t$ \parencite[vgl. ][S. 17]{Zivic2013}.
\end{note}
\subsection{Verallgemeinerte Reed-Solomon-Codes}
\textit{Reed-Solomon-Codes} lassen sich verallgemeinern, in dem ein zusätzlicher Vektor $v =  \langle v_1, ..., v_{n} \rangle$ eingebracht wird.
\begin{definition}
Sei $ u = \langle u_1, u_2, ..., u_n \rangle \in \mathbb{F}_{q}^{n}$, wobei $\forall i, j \in \lbrace 1, ..., n \rbrace \colon u_i \neq u_j$. Ferner sei $v = \langle v_1, v_2, ..., v_n \rangle, \, \forall j \in \lbrace 1, ..., n \rbrace\colon \, v_j \in \mathbb{F}_{q} \setminus \lbrace 0 \rbrace$. Der \textbf{verallgemeinerte Reed-Solomon-Code} $GRS_k(u, v)$ besteht nun aus der Menge der Codeworte
\[c = \langle v_1 f(u_1), v_2 f(u_2), ..., v_n f(u_n)\rangle\] für Polynome $f \in \mathbb{F}_{q}[x]/(x^n - 1)$ mit Grad $\deg f < k$ \parencite[vgl. ][S. 13]{Mahr88}.
\end{definition}
Verallgemeinerte Reed-Solomon-Codes sind im Allgemeinen nicht zyklisch, folglich entfällt die Möglichkeit, ein Generatorpolynom anzugeben. Die Codierung basiert entsprechend auch nicht mehr auf einer Multiplikation des Informationstupels mit dem Generatorpolynom, sondern auf einer Multiplikation mit einer Generatormatrix, die im Folgenden betrachtet wird. Verallgemeinerte Reed-Solomon-Codes finden Verwendung im Ansatz von Niederreiter, da aufgrund der zusätzlich eingebrachten \textbf{Gewichte} die Anzahl der möglichen Codes signifikant steigt und die Codeklasse somit an kryptographischer Bedeutung gewinnt. \\\\
Für den weiteren Verlauf der Arbeit ist die Betrachtung \textbf{dualer Codes} notwendig. Duale Codes können zu linearen Codes gebildet werden:
\subsection{Duale Codes}
\begin{definition}
Sei $C$ ein linearer $[n, k, d]_q$-Code mit Länge $n$, Dimension $k$ und Minimaldistanz $d$ über einem Körper $\mathbb{F}_q$. Ferner bezeichne die Operation $\cdot$ das Skalarprodukt über dem Untervektorraum $\mathbb{F}_{q}^{n}$, das definiert ist durch
\[\langle a_1, a_2, ..., a_n\rangle \cdot \langle b_1, b_2, ..., b_n \rangle = \sum\limits_{i=1}^{n}a_{i}b_{i}\] 
Nun ist der zu $C$ \textbf{duale Code} $C^{\perp}$ definiert als
\[C^{\perp} = \lbrace v \in \mathbb{F}_{p}^{n} \mid v \cdot c = 0, \forall c \in C\rbrace\]
\parencite[vgl. ][S. 35f.]{Manz2017}
\end{definition}

Diese Definition mag an die aus der linearen Algebra im Reellen bekannte Definition von Orthogonalität ({\glqq}Rechtwinkligkeit{\grqq}) erinnern, jedoch lässt sich dies auf die hier betrachteten Körper nicht übertragen, unter Anderem, da es auch \textbf{selbstduale} Codes gibt \parencite[vgl. ][S. 36]{Manz2017}.

\begin{note}
Der zu einem $[n, k, d]_{q}$-Code $C$ duale Code $C^{\perp}$ ist ein $[n, n-k, d]_{q}$-Code \parencite[vgl. ][S. 36]{Manz2017}.
\end{note}

Wird der duale Code zu einem dualen Code eines linearen Codes $C$ gebildet, so ist dieser wieder $C$, also gilt:
\[C^{\perp\perp} = C\]

\begin{theorem}
Der duale Code zu einem Reed-Solomon-Code ist ebenfalls ein Reed-Solomon-Code und der duale Code zu einem verallgemeinerten Reed-Solomon-Code ist ebenfalls ein verallgemeinerter Reed-Solomon-Code \parencite[vgl. ][S. 14]{Mahr88}.
\end{theorem}
So gilt $GRS_k (u, v)^{\perp} = GRS_{n-k} (u, v')$, wobei für die Komponenten des Vektors $v'$ gilt:
\[v_i \cdot v_{i}' \prod\limits_{j=1\\j \neq i}^{n} (u_j - u_i) = 1\]
\parencite[vgl. ][S. 14]{Mahr88}

\subsection{Kontroll- und Generatormatrizen}
Da lineare Codes wie gezeigt Vektorräume bilden, ist die Angabe von \textbf{Basen} möglich. Durch die Definition der Dualität von Codes zueinander, können \textbf{Generator-} und \textbf{Kontrollmatrizen} angegeben werden.
\begin{definition}
Sei $C$ ein linearer $[n, k, d]_{q}$-Code und $C^{\perp}$ der duale Code zu $C$. \\
Ferner sei $\big( \langle h_{11}, h_{12}, ..., h_{1n} \rangle, \langle h_{21}, ..., h_{2n} \rangle, ..., \langle h_{(n-k)1}, ..., h_{(n-k)n} \rangle \big)$ eine Basis zu $C^{\perp}$. Dann ist die Matrix 
\[H = \left( \begin{array}{cccc} h_{11} & h_{12} & ... & h_{1n} \\ h_{21} & h_{22} & ... & h_{2n} \\ ... & ... & ... & ... \\ h_{(n-k)1} & h_{(n-k)2} & ... & h_{(n-k)n}\end{array}\right) \] die \textbf{Generatormatrix} von $C^{\perp}$ und \textbf{Kontrollmatrix} oder \textbf{Paritätsprüfmatrix} von $C$ \parencite[vgl. ][S. 37]{Manz2017}
\end{definition}

Der Zusammenhang zwischen Generator- und Kontrollmatrix ergibt sich daraus, dass über die Generatormatrix des dualen Codes $C^{\perp}$ zu $C$ überprüft werden kann, ob für ein $x \in\mathbb{F}_{q}$ auch $x \in C$ gilt, indem die Skalarprodukte $x \cdot h_i, \forall i \in \lbrace 1, ..., n-k \rbrace$ gebildet werden. Sollte für mindestens eines dieser Produkte $x \cdot h_i \neq 0$ gelten, so ist $x \notin C$ \parencite[vgl. ][S. 37]{Manz2017}. So ließe sich beispielsweise eine Identitätsabbildung $1_{C}(x)$ auf $C$ bilden.

\subsubsection{Generatormatrizen des verallgemeinerten Reed-Solomon-Codes}
Zur Kodierung eines Informationstupels mittels des verallgemeinerten Reed-Solomon-Codes wird die Generatormatrix des Codes benötigt.
\begin{note}
Gegeben sei $GRS_k (u, v)$ und der dazu duale Code $GRS_{n-k}(u, y)$. Die Paritätsprüfmatrix zu $GRS_k (u, v)$ ist dann genau die Generatormatrix zu $GRS_{n-k}(u, y)$ und definiert durch 
\[H = (y_{i} u_{i}^{j})_{0 \leq j \leq n-k-1, \, 1 \leq i \leq n} = 
\left( \begin{array}{cccc}
y_1 & y_2 & \cdots & y_n \\
y_1 u_1 & y_2 u_2 & \cdots & y_n u_n \\
\vdots & \vdots &  & \vdots \\
y_1 u_{1}^{n-k-1} & y_2 u_{2}^{n-k-1} & \cdots & y_n u_{n}^{n-k-1}
\end{array}\right)
\]
Entsprechend ist die Generatormatrix zu $GRS_k (u, v)$ definiert durch 
\[G = (v_{i} u_{i}^{j})_{0 \leq j \leq k-1, \, 1 \leq i \leq n} = 
\left( \begin{array}{cccc}
v_1 & v_2 & \cdots & v_n \\
v_1 u_1 & v_2 u_2 & \cdots & v_n u_n \\
\vdots & \vdots &  & \vdots \\
v_1 u_{1}^{k-1} & v_2 u_{2}^{k-1} & \cdots & v_n u_{n}^{k-1}
\end{array}\right)
\]\parencite[vgl. ][S. 277]{Moon05} und \parencite[vgl. ][S. 304]{MacWilliams77}. 
\end{note}

Diese Matrizen sind für die Kodierung und Dekodierung -- insbesondere auch für die beabsichtigte kryptographische Verwendung -- von besonderer Bedeutung, da mithilfe ihrer Codes definiert werden können und die Frage, ob ein Wort Codewort dieses Codes ist, nun entscheidbar wird. Generatormatrizen lassen sich durch elementare Zeilen- und Spaltenoperationen verändern, sodass zwar weiterhin gültige Codeworte eines Codes $C$ gebildet werden, jedoch wird die Projektion des Informationstupels auf ein Codewort dadurch beeinflusst, sodass womöglich andere Codeworte entstehen. Diese Eigenschaft wird genutzt, um beispielsweise eine systematische Codierung zu ermöglichen.

\section{Kodierung, Fehlerkorrektur und Dekodierung}
In diesem Abschnitt wird mit der algorithmischen Betrachtung der Kodierung und Dekodierung samt der Fehlerkorrektur verallgemeinerter Reed-Solomon-Codes die Grundlage dafür gelegt, ein kryptographisches Verfahren auf Basis fehlerkorrigierender Codes zu konstruieren, wie es \textsc{McEliece} und \textsc{Niederreiter} in ihren Ansätzen tun. \\\\
Sämtliche Listings in diesem Abschnitt zeigen Implementierungen im auf Python basierenden Mathematiksoftwaresystem \textit{SageMath} \parencite{SageMath}. Für die Ausführung dieser Skripte ist ein gegebenenfalls auch virtualisiertes Linux-Betriebssystem erforderlich.
\subsection{Kodierung}
Bei der Codierung linearer Codes im Allgemeinen werden zwei Ansätze unterschieden:
\begin{itemize}
\item \textbf{nicht-systematische Codierung} -- Hier ergeben sich die Codeworte direkt aus der Multiplikation von Informationstupel und einer beliebigen Generatormatrix des Codes.
\item \textbf{systematische Codierung} -- Hier wird eine Generatormatrix der Form $[I_k \mid C ]$ verwendet, wobei $I$ die $k \times k$-Identitätsmatrix und $C$ die $k \times (n-k)$-Codeworterzeugungsmatrix ist. Eine solche Generatormatrix kann durch elementare Zeilen- und Spaltenoperationen erzeugt werden \parencite[vgl. ][S. 84f.]{Moon05}.
\end{itemize}
\subsubsection{Nicht-Systematische Kodierung}
Sei $h = \langle h_0, ..., h_{k-1} \rangle \in \mathbb{F}_{q}^{k}$ ein Informationstupel und $GRS_k (a, v)$ mit $a = \langle a_0, ..., a_{n-1}\rangle$, $\forall i, j \in \lbrace 0, ..., n-1 \rbrace\colon a_i, a_j \in \mathbb{F}_q \land a_i \neq a_j$ und $v = \langle v_0, ..., v_{n-1} \rangle$, $\forall i \in \lbrace 0, ..., n-1 \rbrace\colon v_i \in \mathbb{F}_{q}\setminus \lbrace 0 \rbrace$ ein verallgemeinerter Reed-Solomon-Code. \\\\
Dann ist eine Generatormatrix zu $GRS_k (a, v)$ definiert als
\[G = \left( 
\begin{array}{cccc}
v_0 & v_1 & \cdots & v_{n-1} \\
v_0 a_0 & v_1 a_1 & \cdots & v_{n-1} a_{n-1} \\
\vdots & \vdots & & \vdots \\
v_0 a_{0}^{k-1} & v_1 a_{1}^{k-1} & \cdots & v_{n-1} a_{n-1}^{k-1}
\end{array}
\right)\]
Die nicht-systematische Codierung ist nun gegeben durch die Zeilenvektor-Matrix-Multiplikation von $h$ und $G$ \parencite[vgl. ][S. 37f]{Huffman10}:
\begin{align*}
c &= h \cdot G = \left( \begin{array}{ccc}h_0 & \ldots & h_{k-1}\end{array} \right) \cdot \left( 
\begin{array}{cccc}
v_0 & v_1 & \cdots & v_{n-1} \\
v_0 a_0 & v_1 a_1 & \cdots & v_{n-1} a_{n-1} \\
\vdots & \vdots & & \vdots \\
v_0 a_{0}^{k-1} & v_1 a_{1}^{k-1} & \cdots & v_{n-1} a_{n-1}^{k-1}
\end{array}
\right) \\
&= 
\left( \begin{array}{ccc}h_0 v_0 + h_1 v_0 a_0 + \ldots + h_{k-1} v_0 a_{0}^{k-1} & \cdots &  \end{array} h_0 v_{n-1} + h_1 v_{n-1} a_{n-1} + \ldots + h_{k-1} v_{n-1} a_{n-1}^{k-1}\right) \\
&= \langle c_0, \ldots, c_{n-1}\rangle
\end{align*}
\subsubsection{Systematische Codierung}
Wie bereits beschrieben, ist es für eine systematische Codierung lediglich erforderlich, die Generatormatrix durch Zeilen-/Spaltenoperationen in eine systematische Form zu bringen. Dies kann durch den \textsc{Gauß'schen} Eliminationsalgorithmus mit Pivotierung erreicht werden \parencite[vgl. ][S. 87f]{Moon05}. \\\\
Nun liegt die Generatormatrix in folgender Form vor:
\[ G_S = \left( \begin{array}{cccc|cccc}
1 & 0 & \cdots & 0 & p_{0,0} & p_{0,1} & \cdots & p_{0,n-k-1} \\
0 & 1 & \cdots & 0 & p_{1,0} & p_{1,1} & \cdots & p_{1,n-k-1} \\
\vdots & \vdots & & \vdots & \vdots & \vdots & & \vdots \\
0 & 0 & \cdots & 1 & p_{k-1,0} & p_{k-1,1} & \cdots & p_{k-1,n-k-1}
\end{array}\right)\]
Die systematische Codierung bewirkt nun, dass das Informationstupel unverändert die ersten $k$ Stellen des Codewortes ergibt. Die restlichen Stellen sind $n-k$ Paritätsprüfbits, die über den rechten Teil der Generatormatrix erzeugt werden:
\begin{align*}
c &= h \cdot G_S = \left( \begin{array}{ccc}h_0 & \ldots & h_{k-1}\end{array} \right) \cdot \left( \begin{array}{cccc|cccc}
1 & 0 & \cdots & 0 & p_{0,0} & p_{0,1} & \cdots & p_{0,n-k-1} \\
0 & 1 & \cdots & 0 & p_{1,0} & p_{1,1} & \cdots & p_{1,n-k-1} \\
\vdots & \vdots & & \vdots & \vdots & \vdots & & \vdots \\
0 & 0 & \cdots & 1 & p_{k-1,0} & p_{k-1,1} & \cdots & p_{k-1,n-k-1}
\end{array}\right) \\
&= 
\left( \begin{array}{cccc|ccc}
h_0 & h_1 & \cdots & h_{k-1} &
\sum\limits_{i=0}^{k-1} h_0 p_{i,0} & \cdots & \sum\limits_{i=0}^{k-1} h_{k-1} p_{i,n-k-1} \end{array} \right) \\
&= \langle h_0, h_1, \ldots, h_{k-1}, c_k, c_{k+1}, \ldots, c_{n-1}\rangle
\end{align*}
\subsubsection{Implementierung}
Im Anhang \ref{CodingLst} ist die Implementierung des Kodiervorgangs eines verallgemeinerten Reed-Solomon-Codes über endlichen Körpern in \textit{SageMath} dargestellt. Das Skript generiert aus den Stützstellen und Gewichten eine Generatormatrix für die nicht-systematische Kodierung. Die Generatormatrix für die systematische Kodierung wird dadurch erzeugt, dass die $k \times k$-Untermatrix der ersten $k$ Spalten invertiert und mit $G$ multipliziert wird. Dadurch wird die systematische Form erreicht. Referenzen und alternative Algorithmen sind dem Anhang \ref{MatrixConversion} zu entnehmen.
\subsection{Dekodierung}
Nachdem (nicht-)systematisch erzeugte Codeworte nun über einen unzuverlässigen Kanal übertragen wurden, werden Fehlerkorrektur- und Dekodieralgorithmen angewandt, um die übertragenen Informationen zu erhalten. \\\\
Im Folgenden wird der \textbf{syndrombasierte} Dekodieralgorithmus für eine maximale Fehleranzahl von $\lfloor\frac{n-k}{2}\rfloor$ dargestellt. Der alternative Ansatz des \textbf{listen-basierten} Dekodierens, der die Korrektur von einer größeren Anzahl an Fehlern ermöglicht, wird ohne vertiefte Darstellung erwähnt.
\subsubsection{Syndrombasierter Dekodieralgorithmus}
Gegeben sei ein verallgemeinerter Reed-Solomon-Code $GRS_k (a, v)$ mit Auswertungsstellen $a = \langle a_0, ..., a_{n-1}\rangle$, $\forall i, j \in \lbrace 0, ..., n-1 \rbrace\colon a_i, a_j \in \mathbb{F}_q \land a_i \neq a_j$ und Gewichten $v = \langle v_0, ..., v_{n-1} \rangle$, $\forall i \in \lbrace 0, ..., n-1 \rbrace\colon v_i \in \mathbb{F}_{q}\setminus \lbrace 0 \rbrace$. Ferner sei $\alpha$ primitives Element des zugrundeliegenden Körpers $\mathbb{F}_{q}$. \\
Nach einem Datenübertragungsvorgang wurde ein Tupel $r = \langle r_0, r_1, ..., r_{n-1}\rangle$ empfangen, das sich aus dem korrekten Codeworttupel $c = \langle c_0, c_1, ..., c_{n-1}\rangle$ und einem Fehlertupel $e = \langle e_0, e_1, ..., e_{n-1}\rangle$ zusammensetzt, wobei die Anzahl der Komponenten von $e$, die nicht null sind, nicht größer als $\lfloor\frac{n-k}{2}\rfloor$ sein darf, andernfalls ist es nicht möglich, mit diesem Dekodieralgorithmus das korrekte Codewort aus $r$ zu ermitteln. \\
Basis des Dekodierens bilden nun $n-k-1$ Syndrome, die sich aus der Multiplikation der Paritätsprüfmatrix $H$ mit dem empfangenen Wort $r$ ergeben:
\begin{definition}
Das $l$-te \textbf{Syndrom} eines Wortes $r$ sei definiert als
\[S_l = \sum\limits_{j=0}^{n-1}r_{j}v_{j}\alpha_{j}^{l}\]
\parencite[vgl. ][S. 184]{Roth06}
\end{definition}
Aus der Definition der Paritätsprüfmatrix folgt, dass $r$ genau dann ein gültiges Codewort des betrachteten $GRS_k(a, v)$-Codes ist, falls alle Syndrome gleich null sind. Da zweifelsfrei für jedes Codewort-Syndrom $\sum\limits_{j=0}^{n-1}c_j v_j \alpha_{j}^{l} = 0$ gilt, sind die Fehlerwortsyndrome äquivalent zu den Syndromen obiger Definition. Die Betrachtung dieser Syndrome gibt Aufschluss darüber, an welchen Stellen Fehler während der Übertragung aufgetreten sind.