% !TEX root =  master.tex
\chapter{Lineare fehlerkorrigierende Codes für kryptographische Zwecke}
Mithilfe der vorgestellten Polynome soll nun eine Klasse von Blockcodes betrachtet werden, zu der auch \textit{Reed-Solomon}-Codes und \textit{Goppa}-Codes, die beiden Codes aus den Verfahren von \textsc{Niederreiter} und \textsc{McEliece}, zählen. Diese Klasse wird als \textbf{lineare Codes} bezeichnet. \\\\
Für die Definition linearer Codes ist eine Wiederholung der algebraischen Struktur des \textbf{Vektorraums} notwendig. In \parencite{Fischer2020LA} ist folgende Definition zu finden:
\begin{definition}
Sei $K$ ein Körper. Eine Menge $V$ mit einer additiven Verknüpfung 
\[+ \colon V \times V \to V; \quad \langle v, w \rangle \mapsto v + w\]
und einer Skalarmultiplikation 
\[\circ \colon K \times V \to V; \quad \langle \lambda, v \rangle \mapsto \lambda \circ v\]
heißt \textbf{$K$-Vektorraum}, sofern
\begin{itemize}
\item $(V, +)$ ist \textbf{abelsche Gruppe}
\item Die Skalarmultiplikation ist sowohl bezüglich des Skalars als auch der Komponente distributiv und assoziativ, ferner existiert ein neutrales Element. So muss $\forall \lambda, \mu \in K, v, w \in V$ gelten:
\begin{align*}
( \lambda + \mu ) \circ v &= \lambda \circ v + \mu \circ v \\
\lambda \circ (v + w) &= \lambda \circ v + \lambda \circ w \\
\lambda \circ (\mu \circ v) &= (\lambda \circ \mu ) \circ v \\
1 \circ v &= v
\end{align*}
\end{itemize}
\parencite[vgl.][S. 95]{Fischer2020LA}
\end{definition}
Vektorräume beinhalten folglich Vektoren beliebiger Dimension, deren Komponenten addiert und mit Skalaren multipliziert werden können. Für die Definition linearer Codes ist es erforderlich, Primzahlkörper $\mathbb{F}_{q}^{n}$ als Vektorräume aufzufassen.
\begin{theorem}
Endliche Körper $\mathbb{F}_{q}^{n}$ bilden $\mathbb{F}_{q}$-Vektorräume.
\end{theorem}
\begin{proof}
Es bietet sich an, induktiv vorzugehen:
\begin{itemize}
\item \textbf{Annahme}: $\mathbb{F}_{q}^{n}$ bildet einen Vektorraum $V(q, n)$.
\item \textbf{Induktionsanfang}: Zu zeigen ist, dass $\mathbb{F}_{q}^{1}$ die Forderungen eines Vektorraums erfüllt.
\begin{itemize}
\item Die Forderung danach, dass $(\mathbb{F}_{q}, +)$ eine abelsche Gruppe bildet, folgt unmittelbar aus der Körperdefinition.
\item Die Forderungen nach Distributivität und Assoziativität der Skalarmultiplikation bzw. Addition folgen direkt aus der Ringeigenschaft, da $\lambda, \mu, v \in \mathbb{F}_{q}^{1}$.
\item Die Existenz eines neutralen Elements bezüglich der Skalarmultiplikation ergibt sich daraus, dass gemäß Definition $q \geq 2 > 1 \Rightarrow 1 \in \mathbb{F_q}$ gilt. 
\end{itemize}
\item \textbf{Induktionsschritt $1 \to n$}: Sei die komponentenweise Addition induktiv definiert als \[(v_1, v_2, ..., v_n) + (w_1, w_2, ..., w_n) = (v_1 + w_1, v_2 + w_2, ..., v_n + w_n)\] und die Skalarmultiplikation als
\[k \circ (v_1, v_2, ..., v_n) = (k\circ v_1, k \circ v_2, ..., k \circ v_n)\].
Alle obigen Forderungen folgen damit induktiv und $\mathbb{F}_{q}^{n}$ ist ein $\mathbb{F}_q$-Vektorraum.
\end{itemize}
\end{proof}
\begin{definition}
Ein \textbf{Untervektorraum} $W$ eines Vektorraums $V$ ist eine Teilmenge $W \subset V$, sofern gilt:
\begin{itemize}
\item $W \neq \emptyset$
\item $v, w \in W: \quad v + w \in W$
\item $v \in W, \lambda \in K: \quad \lambda \circ v \in W$ 
\end{itemize}
\parencite[vgl. ][S. 96]{Fischer2020LA}
\end{definition}
\begin{definition}
Sei $\mathbb{F}_q$ ein endlicher Körper, $\lvert K \rvert = q$. Dann ist ein Blockcode $C$ ein \textbf{linearer Code} mit dem Alphabet $\mathbb{F}_q$ und Länge $n$, falls die Menge $C$ ein \textbf{Untervektorraum} von $\mathbb{F}_{q^n}$ ist \parencite[vgl. ][S. 29]{Manz2017}. 
\end{definition}
Folglich beschreibt ein linearer Code Tupel der Länge $n$ mit Komponenten aus $\mathbb{F}_q$. Ferner stellt die Untervektorraum-Eigenschaft sicher, dass die Addition von Codeworten und die Multiplikation eines Codewortes mit einem Skalar aus dem übergeordneten endlichen Körper $\mathbb{F}_q$ weiterhin valide Codeworte erzeugt. Dies ist eine elementare Eigenschaft linearer Codes.
\\\\
Eine Subklasse der linearen Codes sind die \textbf{zyklischen Codes}. 
\section{Zyklische Codes}
\begin{definition}
Ein $k$-dimensionaler Untervektorraum $C$ von $\mathbb{F}_{q}^{n}$ ist dann ein \textbf{zyklischer Code}, wenn
\[\forall \, \langle a_0, a_1, ..., a_{n-1} \rangle \in C: \quad \langle a_{n-1}, a_0, a_1, ..., a_{n-2} \rangle \in C\] gilt \parencite[vgl. ][S. 42]{vanLint1973}.
\end{definition}
Ein linearer Code ist folglich dann zyklisch, falls zu jedem Codewort auch das Codewort Teil des Codes ist, das durch eine zyklische Verschiebung entsteht. Ein solcher Code ist beispielsweise der \textit{Reed-Colomon-Code}, der Gegenstand des nächsten Abschnitts ist.
\begin{theorem}
Zyklische Codes der Länge $n$ sind Ideale des Rings $R = \mathbb{F}_{q}[x]/(x^n -1)$.
\end{theorem}
Das Polynom $x^n - 1$ fungiert hierbei als Modul, sodass der Ring $R$ folglich die Restklassen bezüglich dieser modularen Reduktion von $\mathbb{F}_{q}$ enthält.
\begin{note}
Sei $C$ ein linearer zyklischer Code der Länge $n$ über einem Körper $F_{q}$ und $a = a(x) = a_0 + a_{1}\cdot x + ... + a_{n-1}\cdot x^{n-1} \in C$. Dann ist 
\begin{align*}
&x \cdot a \\
& = x \cdot (a_0 + a_{1} \cdot x + ... + a_{n-1}\cdot x^{n-1}) \\
& = a_0 \cdot x + a_{1} \cdot x^2 + ... + a_{n-1} \cdot x^n  \\
& = a_{n-1} + a_{0}\cdot x + ... + a_{n-2} \cdot x^{n-1}
\end{align*}
genau das zyklisch verschobene Codewort $a' \in C$. \\
Dies folgt aus $x^n \equiv 1 \mod x^n - 1$ \parencite[vgl. ][S. 149f.]{Biggs08}.
\end{note}
Da durch die Linearität des Codes $C$ lässt sich ein $a \in C$ nicht nur beliebig oft zyklisch verschieben, also mit $x$ multiplizieren, sondern auch lineare Kombinationen (also Summen) gültiger Codeworte ergeben wiederum ein gültiges Codewort in $C$. Somit ergibt auch das Produkt eines Codewortes mit einem Polynom, also 
\[a(x) \cdot c(x) \in C, \, c(x) \in C,\, a \in \mathbb{F}_{q}[x]/(x^n - 1)\] 
ein gültiges Codewort \parencite[vgl. ][S. 121]{Moon05}. \\\\
Da Ideale erzeugende Polynome besitzen, ist die Angabe eines \textbf{Generatorpolynoms} $g(x)$ möglich, für das gilt:
\begin{itemize}
\item $\deg g(x) = n - k$
\item $g(x) \mid (x^n - 1)$
\end{itemize} 
\begin{theorem}
Sei $C$ ein linearer zyklischer Code über einem endlichen Körper $\mathbb{F}_{q}$. Dann gibt es ein Polynom $g(x)$, für das $C = \langle g(x) \rangle$ gilt.
\end{theorem}
Ein Codewort beziehungsweise ein Codewortpolynom $c(x)$ eines linearen, zyklischen Codes mit Generatorpolynom $g(x)$ kann nun als Produkt von Nachrichtpolynom $m(x)$ und Generatorpolynom aufgefasst werden \parencite[vgl. ][S. 121]{Moon05}.
\[c(x) = m(x) \cdot g(x)\]
Bei vielen aktuellen Anwendungen von \textit{Reed-Solomon-Codes} werden Generatorpolynome angegeben und genutzt \parencite[vgl. ][S. 6]{WBC11994}.
\section{Definition der Klasse von Reed-Solomon-Codes}
Die grundlegende Idee von linearen zyklischen Codes über Polynomen besteht darin, Fehler über Interpolation zu korrigieren. Bildlich gesehen soll also ein Codewort konstruiert werden, dessen einzelnen Komponenten entlang einer interpolierbaren Abbildung aufgereiht sind. Sollte nun ein Übertragungsfehler die Lage eines Punktes (also einer Komponente) verändern, so ist die korrekte Lage durch die anderen Punkte jedoch hinreichend bestimmt und kann korrigiert werden.
\paragraph{Idee}
Eine Nachricht der Länge $k$ in Form eines Elementes eines endlichen Körpers $\mathbb{F}_{q}^{k}$ kann als Polynom aufgefasst werden, indem die entsprechenden Komponenten der Nachricht die Koeffizienten des Polynoms bilden. Werden nun $n$ paarweise verschiedene Stützstellen aus dem dem Code zugrundeliegenden Körper $\mathbb{F}_{q}^{n}$ ausgewählt, so ergibt die Auswertung des Polynoms an den jeweiligen Stützstellen die Komponenten eines betrachteten Codewortes. \\\\
Durch bereits $k$ Komponenten des Codewortes ist das Polynom hinreichend bestimmt, sodass $n-k$ Punkte, die während der Übertragung ausgelöscht wurden, und $(n-k)/2$ verfläscht übertragene Punkte als Fehler erkannt und korrigiert werden können.
\begin{definition}
Sei $u = \langle u_1, u_2, ..., u_n \rangle \in \mathbb{F}_{q}^{n}$, wobei $\forall i, j \in \lbrace 1, ..., n \rbrace : u_i \neq u_j$. Dann ist $a = \langle a_1, a_2, ..., a_n \rangle \in \mathbb{F}_{q}^{n}$ ein Codewort eines \textbf{Reed-Solomon-Codes} $C$ mit Länge $n$, Dimension $k$ und Minimaldistanz $d$, falls gilt:
\[C = \lbrace a \mid a_i = f(u_i), \deg f(x) < k, f \in \mathbb{F}_{q}^{n}[x] \rbrace\]
\parencite[vgl. ][S. 9]{Mahr88}
\end{definition}
\begin{example}
Sei $a = \langle 0, 1, 2, 1 \rangle \in \mathbb{F}_{7}^{4}$. Dann ist $f(X) = 0 + 1 \circ X + 2 \circ X^2 + 1 \circ X^3 \in \mathbb{F}_{7}[X]$ ein dazugehöriges Polynom. \\\\
Betrachtet werde nun ein \textbf{Reed-Solomon-Code} $C$ mit Länge $n = 7$ und Dimension $k = 4$:
\[C = \lbrace a \mid a_i = f(u_i), \deg f(x) < 4, f \in \mathbb{F}_{7}^{7}[x]\rbrace\]
\begin{itemize}
\item Gewählt sind folglich $n$ paarweise verschiedene Stützstellen, deren Wahlfreiheit in $\mathbb{F}_7$ lediglich in der Anordnung besteht. Möglich ist beispielsweise $u = \langle 0, 1, 2, 3, 4, 5, 6 \rangle \in \mathbb{F}_{7}^{7}$.
\item Auswertung:
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
Stützstelle $u_i$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
\hline
Auswertung $f(u_i)$& 0 & 4 & 4 & 6 & 2 & 5 & 0 \\ 
\hline
\end{tabular}
\item Folglich ergibt sich das Codewort $c = \langle 0, 4, 4, 6, 2, 5, 0 \rangle \in \mathbb{F}_{7}^{7}$.
\end{itemize}
\end{example}
\begin{note}
Das Generatorpolynom zu einem \textit{Reed-Solomon-Code} ist definiert durch
\[g(x) = \prod_{j = 1}^{2t} (x - a^{j})\]
wobei $t$ die Anzahl der durch diesen Code korrigierbaren Fehler repräsentiert, es gilt $n - k = 2t$ \parencite[vgl. ][S. 17]{Zivic2013}.
\end{note}
Nun wird in der Literatur gelegentlich auch der zu einem \textit{Reed-Solomon-Code} \textbf{duale Code} verwendet:
\subsection{Duale Codes}
\begin{definition}
Sei $C$ ein linearer $[n, k, d]_q$-Code mit Länge $n$, Dimension $k$ und Minimaldistanz $d$ über einem Körper $\mathbb{F}_q$. Ferner bezeichne die Operation $\cdot$ das Skalarprodukt über dem Untervektorraum $\mathbb{F}_{q}^{n}$, das definiert ist durch
\[\langle a_1, a_2, ..., a_n\rangle \cdot \langle b_1, b_2, ..., b_n \rangle = \langle a_{1}b_{1}, a_{2}b_{2}, ..., a_{n}b_{n} \rangle\] 
Nun ist der zu $C$ \textbf{duale Code} $C^{\perp}$ definiert als
\[C^{\perp} = \lbrace v \in \mathbb{F}_{p}^{n} \mid v \cdot c = 0, \forall c \in C\rbrace\]
\parencite[vgl. ][S. 35f.]{Manz2017}
\end{definition}

Diese Definition mag an die aus der linearen Algebra im Reellen bekannte Definition von Orthogonalität ({\glqq}Rechtwinkligkeit{\grqq}) erinnern, jedoch lässt sich dies auf die hier betrachteten Körper nicht übertragen, unter Anderem, da es auch \textbf{selbstduale} Codes gibt \parencite[vgl. ][S. 36]{Manz2017}.

\begin{note}
Der zu einem $[n, k, d]_{q}$-Code $C$ duale Code $C^{\perp}$ ist ein $[n, n-k, d]_{q}$-Code \parencite[vgl. ][S. 36]{Manz2017}.
\end{note}

Wird der duale Code zu einem dualen Code eines linearen Codes $C$ gebildet, so ist dieser wieder $C$, also gilt:
\[C^{\perp\perp} = C\]

\subsection{Kontroll- und Generatormatrizen}
Da lineare Codes wie gezeigt Vektorräume bilden, ist die Angabe von \textbf{Basen} möglich. Durch die Definition der Dualität von Codes zueinander, können \textbf{Generator-} und \textbf{Kontrollmatrizen} angegeben werden.
\begin{definition}
Sei $C$ ein linearer $[n, k, d]_{q}$-Code und $C^{\perp}$ der duale Code zu $C$. \\
Ferner sei $\big( \langle h_{11}, h_{12}, ..., h_{1n} \rangle, \langle h_{21}, ..., h_{2n} \rangle, ..., \langle h_{(n-k)1}, ..., h_{(n-k)n} \rangle \big)$ eine Basis zu $C^{\perp}$. Dann ist die Matrix 
\[H = \left( \begin{array}{cccc} h_{11} & h_{12} & ... & h_{1n} \\ h_{21} & h_{22} & ... & h_{2n} \\ ... & ... & ... & ... \\ h_{(n-k)1} & h_{(n-k)2} & ... & h_{(n-k)n}\end{array}\right) \] die \textbf{Generatormatrix} von $C^{\perp}$ und \textbf{Kontrollmatrix} von $C$ \parencite[vgl. ][S. 37]{Manz2017}
\end{definition}

Der Zusammenhang zwischen Generator- und Kontrollmatrix ergibt sich daraus, dass über die Generatormatrix des dualen Codes $C^{\perp}$ zu $C$ überprüft werden kann, ob für ein $x \in\mathbb{F}_{q}$ auch $x \in C$ gilt, indem die Skalarprodukte $x \cdot h_i, \forall i \in \lbrace 1, ..., n-k \rbrace$ gebildet werden. Sollte für mindestens eines dieser Produkte $x \cdot h_i \neq 0$ gelten, so ist $x \notin C$ \parencite[vgl. ][S. 37]{Manz2017}. So ließe sich beispielsweise eine Identitätsabbildung $1_{C}(x)$ auf $C$ bilden.

\section{QR-Codes als Anwendungsbeispiel}
\textit{Reed-Solomon-Codes} finden aufgrund ihrer vergleichsweise einfachen Codierbarkeit Anwendung in einer Vielzahl von Problemstellungen des Alltags: Neben der Raumfahrt oder der korrekten Wiedergabe von CDs sind sie auch Teil von \textit{QR-Codes}, die im Folgenden als Anwendungsbeispiel betrachtet werden.
\subsection{Hintergrund und Konzept}
\textit{\ac{QR}-Codes\footnote{Aufgrund des fehlenden Zugriffs auf die spezifizierende ISO-Norm in der aktuellen Fassung bezieht sich diese Arbeit auf den Stand von 2000.}} sind zweidimensionale Matrix-Codes, die 1994 von einer Tochterfirma des Automobilherstellers Toyota entwickelt wurden, ursprünglich, um die Nachverfolgung von Fahrzeugkomponenten zu gewährleisten \parencite[vgl. ][S. 1]{QROverview2016}. Ziel der Entwicklung war es, ein Barcode-Format zu entwickeln, dass hochperformant und einfach zu scannen ist \parencite[vgl. ][S. 1]{QROverview2016}. Kodierbare Daten sind beispielsweise alphanumerische Zeichenketten, URLs oder Bytedata.
\subsubsection{Fehlerkorrektur}
Zwei Arten von Fehlern sind möglich:
\begin{itemize}
\item \textbf{Erasure} -- Ein Symbol, das nicht gescannt oder dekodiert werden kann
\item \textbf{Error} -- Ein Symbol, das falsch dekodiert wurde
\end{itemize}
Durch die Matrixform des Codes führt ein irrtümlich als hell oder dunkel erkanntes Symbol weiterhin zu einem gültigen, wenn auch falschen Codewort. Zur Korrektur dieses falschen Codewortes sind zwei Korrekturworte erforderlich \parencite[vgl. ][S. 33]{ISO18004}. \\\\
Je nach gewählter Qualitätsstufe ist eine verschiedene Anzahl von Korrekturworten erforderlich, die den Tabellen der ISO-Norm 18004 in der jeweils gültigen Fassung entnommen werden können \parencite[vgl. ][S. 35-44]{ISO18004}. Zu jedem Datenwort (bei Bedarf mit Padding-Worten) wird ein Fehlerkorrekturwort berechnet und an die Daten angefügt.
\subsection{Konstruktion von Fehlerkorrekturworten}
Verwendet wird der Galois-Körper $\mathbb{F}_{2^8}$ mit dem definierenden und auf diesem Körper irreduziblen Polynom $x^8 + x^4 + x^3 + x^2 + 1$. \\\\
Die \textbf{Datencodeworte} bilden nun die Koeffizienten eines Polynoms, wobei das erste Datencodewort die Koeffizienten des Terms mit dem höchsten Grad repräsentieren und das letzte Datencodewort entsprechend die Koeffizienten des Terms mit dem niedrigsten Grad \parencite[vgl. ][S. 45]{ISO18004}. 
\\\\
Dieses Polynom wird nun durch ein für jede QR-Code-Konfiguration in \cite{ISO18004} definiertes \textbf{Generatorpolynom} dividiert. Der dabei entstehende Rest bildet nun die \textbf{Fehlerkorrekturworte}, indem der Koeffizient des Terms mit dem höchsten Grad das erste Fehlerkorrekturwort und der Koeffizient des Terms mit Grad $0$ das letzte Fehlerkorrekturwort definiert \parencite[vgl. ][S. 45]{ISO18004}. \\\\
Die nun generierten Datencodeworte und Fehlerkorrekturworte ergeben nach einer spezifizierten Anordnung nun die grafische Repräsentation des QR-Codes:
\begin{figure}[h!]
\centering
\includegraphics[scale=0.7]{img/QR-arrangement.PNG}
\caption{Anordnung einzelner Datencodeworte und Fehlerkorrekturcodeworte in einem QR-Code \parencite[][S. 48]{ISO18004}}
\end{figure}
\subsection{Dekodierung}
Für die folgenden Schritte wird ein \textit{\ac{QR}-Code} in der Version 1-M betrachtet. Gemäß der Norm wird für diese Version der $[26, 16, 4]_{2^8}$-Reed-Solomon-Code verwendet.\begin{enumerate}
\item \textbf{Demaskierung} -- Die Daten des QR-Codes sind zum Zweck einer besseren Scan-Qualität maskiert worden, diese Maskierung wird als erstes entfernt, es ergibt sich das empfangene Codewort (mit potenziellen Fehlern) \[R(x) = r_0 + r_{1}x^{1} + ... + r_{25}x^{25}\]
wobei $\forall i \in \lbrace 1, ..., 25 \rbrace\colon r_i \in \mathbb{F}_{2^8}$.
\item \textbf{Syndrombildung} -- Ausgehend von der Annahme, dass die Daten als Summe $c(x) + e(x)$ von Codewortpolynom und einem Fehlerpolynom vorliegen, soll nun bestimmt werden, ob Fehler vorliegen. Dafür werden alle \textbf{Syndrome} $S_{i} = R(\alpha^{j}),\, \forall j \in \lbrace 1, ..., 2t \rbrace \land i \in \lbrace 0, ..., 8 \rbrace$ wobei $\alpha$ primitives Element des Körpers $\mathbb{F}_{q}$ ist, gebildet, da das Codewortpolynom für alle Wurzeln des Generatorpolynoms (also die Nullstellen) gemäß dem Nullproduktsatz $0$ ergibt und somit lediglich die Fehlerpolynome verbleiben.
\item \textbf{Fehlerpositionsermittlung} -- Für die Ermittlung der Fehlerpositionen wird folgendes Gleichungssystem aus den Syndromen gebildet:
\begin{align*}
S_0 Y_4 - S_1 Y_3 + S_2 Y_2 - S_3 Y_1 + S_4 = 0 \\
S_1 Y_4 - S_2 Y_3 + S_3 Y_2 - S_4 Y_1 + S_5 = 0 \\
S_2 Y_4 - S_3 Y_3 + S_4 Y_2 - S_5 Y_1 + S_6 = 0 \\
S_3 Y_4 - S_4 Y_3 + S_5 Y_2 - S_6 Y_1 + S_7 = 0
\end{align*}
Da Addition und Subtraktion in einem endlichen Körper der Primcharakteristik $2$ gleichbedeutend sind, führen die alternierenden Vorzeichen nicht zu einer Abweichung vom später dargestellten Allgemeinfall. \\\\
Dieses Gleichungssystem hat mindestens eine nicht-triviale Lösung, sofern die tatsächliche Fehleranzahl $w(e) \leq t$ ist. Mit dieser Lösung ergibt sich das \textbf{Fehlerlokalisiationspolynom}
\[\sigma(x) = Y_4 + Y_3x + Y_2x^2 + Y_1x^3 + x^4\]
\item Falls $\sigma(\alpha^j) = 0, \, j \in \lbrace 0, ..., n-1 \rbrace$, so liegt an dieser Stelle $j$ ein Fehler vor. Die Menge aller Fehlerstellen $N(\sigma)$ sei definiert als $\lbrace i= \lbrace 1, ..., n \rbrace \mid \sigma(\alpha^{i}) = 0 \rbrace$.
\item \textbf{Fehlerwertbestimmung} -- Nun werden die einzelnen Fehlerwerte durch folgendes Gleichungssystem berechnet:
\begin{align*}
E_{i_1}\cdot \alpha^{1j_1} + E_{i_2}\cdot \alpha^{1j_2} + ... + E_{i_{w(e)}}\cdot \alpha^{1j_{w(e)}} &= S_0 \\
E_{i_1}\cdot \alpha^{2j_1} + E_{i_2}\cdot \alpha^{2j_2} + ... + E_{i_{w(e)}}\cdot \alpha^{2j_{w(e)}} &= S_1 \\
... \\
E_{i_1}\cdot \alpha^{(n-k-1)j_1} + E_{i_2}\cdot \alpha^{(n-k-1)j_2} + ... + E_{i_{w(e)}}\cdot \alpha^{(n-k-1)j_{w(e)}} &= S_{(n-k-1)} \\
\end{align*}
\item \textbf{Fehlerkorrektur} -- Sollte das obige Gleichungssystem eine nicht-triviale Lösung haben, so lassen sich die Fehler korrigieren. Sei $(\epsilon_{i_1}, \epsilon_{i_2}, ..., \epsilon_{i_{w(e)}})$ diese Lösung. Sie wird nun zu einem alle Stellen umfassenden Tupel $(\epsilon_1, ..., \epsilon_n)$ erweitert, wobei für alle Stellen $i \notin N(\sigma)\colon \epsilon_i = 0$ gilt. Die eigentliche Korrektur wird nun über 
\[C = R - (\epsilon_1, ..., \epsilon_n)\]
ausgeführt, wobei $C$ nun das korrigierte Codewort darstellt.
\end{enumerate}
\parencite[vgl. ][S. 74f.]{ISO18004}
\section{Algorithmische Betrachtung}
Ziel dieses Abschnittes ist es, die Kodierung von Dekodierung von \textit{Reed-Solomon-Codes} als implementierbare Algorithmen zu zeigen, um anschließend darauf aufbauend ein kryptographisches Verfahren entwickeln zu können.
\subsection{Kodierung}
Eine Nachricht $m$ soll ergänzt um ein Fehlerkorrekturcodewort $c$ über einen Kanal übertragen werden. Sender und Empfänger haben sich vor Datenübermittlung auf die Parameter $n, k, d$ und $q$ eines $[n, k, d]_{q}$-\textit{Reed-Solomon-Codes} geeinigt. 
\begin{enumerate}
\item Bilden des \textbf{Generatorpolynoms} mit $\alpha$ als primitivem Element
\[g(x) = (x - \alpha^1) \cdot (x - \alpha^2) \cdot (x - \alpha^3) \cdot ... \cdot (x - \alpha^{2t})\]
\item Bildung des Polynoms der Nachricht ($m \to m(x)$)
\[m(x) = m_0 + m_{1}x + m_{2}x^2 + ... + m_{k-1}x^{k-1}, \, \forall i \in \lbrace0, ..., k-1 \rbrace \colon m_i \in \mathbb{F}_{q}\]
\item Berechnen des \textbf{Fehlerkorrekturwortes}
\[r(x) = m(x) \cdot x^{n-k} \mod g(x)\]
Es ist bekannt, dass $c(x) = m(x)g(x)$ gilt. Diese Vorgehensweise hat jedoch den Nachteil, dass sich die zur Fehlerkorrektur zusätzlich eingebrachten Prüfbits an Stellen des Polynoms befinden, die im Codewort eine saubere Trennung in Informations- und Prüfbits unmöglich machen. Daher wird ein anderer Ansatz gewählt, bei dem die zusätzlichen Prüfbits an die Nachricht angehängt werden, während die Nachricht selbst unverändert übernommen wird \parencite[vgl. ][S. 127f.]{Manz2017}
\item \textbf{Zusammensetzen}
\[c(x) = m(x) \cdot x^{n-k} + r(x) \]
Würde hier bloß $c(x) = m(x) + r(x)$ angegeben sein, so könnte nicht ausgeschlossen werden, das sich Terme gleichen Grades gegenseitig aufheben. Daher wird der Informationsteil des Codewortes mittels Multiplikation um $x^{n-k}$ an höhere Potenzen verschoben. In einer technischen Realisierung werden zu diesem Zweck Schieberegister eingesetzt \parencite[vgl. ][S. 126f.]{Manz2017}. Es ergibt sich folglich ein Codewort \[c = \langle r_0, ..., r_{n-k-1}, m_{n-k}, m_{n-k+1}, ..., m_{n-1} \rangle\]
\parencite[vgl. ][S. 17]{Zivic2013}
\end{enumerate}
\subsubsection{Implementierung}
Das folgende Listing zeigt den systematischen Kodieralgorithmus nach \parencite{Zivic2013} und \parencite{Manz2017} in einer Implementierung im Mathematiksoftwaresystem \textit{SageMath} \parencite{SageMath}.
\begin{lstlisting}[language=Python, caption={SageMath-Implementierung des Kodieralgorithmus}]
#!/usr/bin/env sage
# ...

# Basic Code properties
q = input("Please type in q, e.g. 2^2: \t")
n = int(input("Please type in length n: \t"))
k = int(input("Please type in dimension k: \t"))

# Generate Galois field
F_q = None
if len(q.split("^")) < 2:
  F_q.<a> = GF(int(q))
elif len(q.split("^")) == 2:
  F_q.<a> = GF(pow(int(q.split("^")[0]), int(q.split("^")[1])))
else:
  print(f"Sorry, unable to work with this q={q}!")

# Generate RS-Code
R.<x> = PolynomialRing(F_q)
g = prod(x - a**i for i in range(1, n-k+1))
print(f"\nGenerator Polynomial: \t\t{g}")	

# Convert Message m=(m_0, m_1, ..., m_{k-1}) to polynomial
m = input(f"\nPlease type in message tupel\n
  (m0,m1,...,m{k-1}) of F_({q})^{k}: \t")
m = [F_q(x) for x in m[1:-1].split(",")]

if len(m) != k:
  print("\nERROR: The provided message has not exactly k digits!")
  exit()

m_poly = 0
i = 0
while i < len(m):
  m_poly += (m[i])*(x**i)
  i += 1

print(f"\nMessage Polynomial: \t\t{m_poly}")

# Coding steps
(_, r) = (m_poly * x**(n-k)).quo_rem(g)
print(f"\nRemainder Polynomial: \t\t{r}")

m_shifted = (m_poly * x**(n-k))
print(f"\nShifted Message Polynomial: \t{m_shifted}")

c = m_shifted + r
print(f"Concatenated Codeword: \t\t{c}")

coefficients = c.coefficients(sparse=False)

while len(coefficients) < n:
  coefficients = [0]+coefficients

print(f"\nCodeword Coefficients: \t\t{coefficients}")
\end{lstlisting}






 

