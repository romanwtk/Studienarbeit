% !TEX root =  master.tex
\chapter{Lineare fehlerkorrigierende Codes für kryptographische Zwecke}
Mithilfe der vorgestellten Polynome soll nun eine Klasse von Blockcodes betrachtet werden, zu der auch \textit{Reed-Solomon}-Codes und \textit{Goppa}-Codes, die beiden Codes aus den Verfahren von \textsc{Niederreiter} und \textsc{McEliece}, zählen. Diese Klasse wird als \textbf{lineare Codes} bezeichnet. \\\\
Für die Definition linearer Codes ist eine Wiederholung der algebraischen Struktur des \textbf{Vektorraums} notwendig. In \parencite{Fischer2020LA} ist folgende Definition zu finden:
\begin{definition}
Sei $K$ ein Körper. Eine Menge $V$ mit einer additiven Verknüpfung 
\[+ \colon V \times V \to V; \quad \langle v, w \rangle \mapsto v + w\]
und einer Skalarmultiplikation 
\[\circ \colon K \times V \to V; \quad \langle \lambda, v \rangle \mapsto \lambda \circ v\]
heißt \textbf{$K$-Vektorraum}, sofern
\begin{itemize}
\item $(V, +)$ ist \textbf{abelsche Gruppe}
\item Die Skalarmultiplikation ist sowohl bezüglich des Skalars als auch der Komponente distributiv und assoziativ, ferner existiert ein neutrales Element. So muss $\forall \lambda, \mu \in K, v, w \in V$ gelten:
\begin{align*}
( \lambda + \mu ) \circ v &= \lambda \circ v + \mu \circ v \\
\lambda \circ (v + w) &= \lambda \circ v + \lambda \circ w \\
\lambda \circ (\mu \circ v) &= (\lambda \circ \mu ) \circ v \\
1 \circ v &= v
\end{align*}
\end{itemize}
\parencite[vgl.][S. 95]{Fischer2020LA}
\end{definition}
Vektorräume beinhalten folglich Vektoren beliebiger Dimension, deren Komponenten addiert und mit Skalaren multipliziert werden können. Für die Definition linearer Codes ist es erforderlich, Primzahlkörper $\mathbb{F}_{q^n}$ als Vektorräume aufzufassen.
\begin{theorem}
Endliche Körper $\mathbb{F}_{q}^{n}$ bilden $\mathbb{F}_{q}$-Vektorräume.
\end{theorem}
\begin{proof}
Es bietet sich an, induktiv vorzugehen:
\begin{itemize}
\item \textbf{Annahme}: $\mathbb{F}_{q}^{n}$ bildet einen Vektorraum $V(q, n)$.
\item \textbf{Induktionsanfang}: Zu zeigen ist, dass $\mathbb{F}_{q}^{1}$ die Forderungen eines Vektorraums erfüllt.
\begin{itemize}
\item Die Forderung danach, dass $(\mathbb{F}_{q}, +)$ eine abelsche Gruppe bildet, folgt unmittelbar aus der Körperdefinition.
\item Die Forderungen nach Distributivität und Assoziativität der Skalarmultiplikation bzw. Addition folgen direkt aus der Ringeigenschaft, da $\lambda, \mu, v \in \mathbb{F}_{q}^{1}$.
\item Die Existenz eines neutralen Elements bezüglich der Skalarmultiplikation ergibt sich daraus, dass gemäß Definition $q \geq 2 > 1 \Rightarrow 1 \in \mathbb{F_q}$ gilt. 
\end{itemize}
\item \textbf{Induktionsschritt $1 \to n$}: Sei die komponentenweise Addition induktiv definiert als \[(v_1, v_2, ..., v_n) + (w_1, w_2, ..., w_n) = (v_1 + w_1, v_2 + w_2, ..., v_n + w_n)\] und die Skalarmultiplikation als
\[k \circ (v_1, v_2, ..., v_n) = (k\circ v_1, k \circ v_2, ..., k \circ v_n)\].
Alle obigen Forderungen folgen damit induktiv und $\mathbb{F}_{q}^{n}$ ist ein $\mathbb{F}_q$-Vektorraum.
\end{itemize}
\end{proof}
\begin{definition}
Ein \textbf{Untervektorraum} $W$ eines Vektorraums $V$ ist eine Teilmenge $W \subset V$, sofern gilt:
\begin{itemize}
\item $W \neq \emptyset$
\item $v, w \in W: \quad v + w \in W$
\item $v \in W, \lambda \in K: \quad \lambda \circ v \in W$ 
\end{itemize}
\parencite[vgl. ][S. 96]{Fischer2020LA}
\end{definition}
\begin{definition}
Sei $\mathbb{F}_q$ ein endlicher Körper, $\lvert K \rvert = q$. Dann ist ein Blockcode $C$ ein \textbf{linearer Code} mit dem Alphabet $\mathbb{F}_q$ und Länge $n$, falls die Menge $C$ ein \textbf{Untervektorraum} von $\mathbb{F}_{q^n}$ ist \parencite[vgl. ][S. 29]{Manz2017}. 
\end{definition}
Folglich beschreibt ein linearer Code Tupel der Länge $n$ mit Komponenten aus $\mathbb{F}_q$. Ferner stellt die Untervektorraum-Eigenschaft sicher, dass die Addition von Codeworten und die Multiplikation eines Codewortes mit einem Skalar aus dem übergeordneten endlichen Körper $\mathbb{F}_q$ weiterhin valide Codeworte erzeugt. Dies ist eine elementare Eigenschaft linearer Codes.
\\\\
Eine Subklasse der linearen Codes sind die \textbf{zyklischen Codes}. 
\begin{definition}
Ein $k$-dimensionaler Untervektorraum $C$ von $\mathbb{F}_{q}^{n}$ ist dann ein \textbf{zyklischer Code}, wenn
\[\forall \, \langle a_0, a_1, ..., a_{n-1} \rangle \in C: \quad \langle a_{n-1}, a_0, a_1, ..., a_{n-2} \rangle \in C\] gilt \parencite[vgl. ][S. 42]{vanLint1973}.
\end{definition}
Ein linearer Code ist folglich dann zyklisch, falls zu jedem Codewort auch das Codewort Teil des Codes ist, das durch eine zyklische Verschiebung entsteht. Ein solcher Code ist beispielsweise der \textit{Reed-Colomon-Code}, der Gegenstand des nächsten Abschnitts ist. Zyklische Codes ermöglichen es, durch ein \textbf{Generatorpolynom} definiert zu werden. Dies ist bei vielen aktuellen Anwendungen von \textit{Reed-Solomon-Codes} der Fall \parencite[vgl. ][S. 6]{WBC11994}.
\\\\
Ein Codewort (beziehungsweise ein Codewortpolynom) $c(x)$ eines linearen, zyklischen Codes mit Generatorpolynom $g(x)$ kann als Produkt von Nachrichtpolynom $m(x)$ und Generatorpolynom aufgefasst werden.
\[c(x) = m(x) \cdot g(x)\]
\section{Reed-Solomon-Codes}
Die grundlegende Idee von linearen zyklischen Codes über Polynomen besteht darin, Fehler über Interpolation zu korrigieren. Bildlich gesehen soll also ein Codewort konstruiert werden, dessen einzelnen Komponenten entlang einer interpolierbaren Abbildung aufgereiht sind. Sollte nun ein Übertragungsfehler die Lage eines Punktes (also einer Komponente) verändern, so ist die korrekte Lage durch die anderen Punkte jedoch hinreichend bestimmt und kann korrigiert werden.
\paragraph{Idee}
Eine Nachricht der Länge $k$ in Form eines Elementes eines endlichen Körpers $\mathbb{F}_{q}^{k}$ kann als Polynom aufgefasst werden, indem die entsprechenden Komponenten der Nachricht die Koeffizienten des Polynoms bilden. Werden nun $n$ paarweise verschiedene Stützstellen aus dem dem Code zugrundeliegenden Körper $\mathbb{F}_{q}^{n}$ ausgewählt, so ergibt die Auswertung des Polynoms an den jeweiligen Stützstellen die Komponenten eines betrachteten Codewortes. \\\\
Durch bereits $k$ Komponenten des Codewortes ist das Polynom hinreichend bestimmt, sodass $n-k$ Punkte, die nicht auf dem Polynom liegen, als Fehler erkannt und korrigiert werden können.
\begin{definition}
Sei $u = \langle u_1, u_2, ..., u_n \rangle \in \mathbb{F}_{q}^{n}$, wobei $\forall i, j \in \lbrace 1, ..., n \rbrace : u_i \neq u_j$. Dann ist $a = \langle a_1, a_2, ..., a_n \rangle \in \mathbb{F}_{q}^{n}$ ein Codewort eines \textbf{Reed-Solomon-Codes} $C$ mit Länge $n$, Dimension $k$ und Minimaldistanz $d$, falls gilt:
\[C = \lbrace a \mid a_i = f(u_i), \deg f(x) < k, f \in \mathbb{F}_{q}^{n}[x] \rbrace\]
\parencite[vgl. ][S. 9]{Mahr88}
\end{definition}
\begin{example}
Sei $a = \langle 0, 1, 2, 1 \rangle \in \mathbb{F}_{7}^{4}$. Dann ist $f(X) = 0 + 1 \circ X + 2 \circ X^2 + 1 \circ X^3 \in \mathbb{F}_{7}[X]$ ein dazugehöriges Polynom. \\\\
Betrachtet werde nun ein \textbf{Reed-Solomon-Code} $C$ mit Länge $n = 7$ und Dimension $k = 4$:
\[C = \lbrace a \mid a_i = f(u_i), \deg f(x) < 4, f \in \mathbb{F}_{7}^{7}[x]\rbrace\]
\begin{itemize}
\item Gewählt sind folglich $n$ paarweise verschiedene Stützstellen, deren Wahlfreiheit in $\mathbb{F}_7$ lediglich in der Anordnung besteht. Möglich ist beispielsweise $u = \langle 0, 1, 2, 3, 4, 5, 6 \rangle \in \mathbb{F}_{7}^{7}$.
\item Auswertung:
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
Stützstelle $u_i$ & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
\hline
Auswertung $f(u_i)$& 0 & 4 & 4 & 6 & 2 & 5 & 0 \\ 
\hline
\end{tabular}
\item Folglich ergibt sich das Codewort $c = \langle 0, 4, 4, 6, 2, 5, 0 \rangle \in \mathbb{F}_{7}^{7}$.
\end{itemize}
\end{example}
Nun wird in der Literatur gelegentlich auch der zu einem \textit{Reed-Solomon-Code} \textbf{duale Code} verwendet:
\subsection{Duale Codes}
\begin{definition}
Sei $C$ ein linearer $[n, k, d]_q$-Code mit Länge $n$, Dimension $k$ und Minimaldistanz $d$ über einem Körper $\mathbb{F}_q$. Ferner bezeichne die Operation $\cdot$ das Skalarprodukt über dem Untervektorraum $\mathbb{F}_{q}^{n}$, das definiert ist durch
\[\langle a_1, a_2, ..., a_n\rangle \cdot \langle b_1, b_2, ..., b_n \rangle = \langle a_{1}b_{1}, a_{2}b_{2}, ..., a_{n}b_{n} \rangle\] 
Nun ist der zu $C$ \textbf{duale Code} $C^{\perp}$ definiert als
\[C^{\perp} = \lbrace v \in \mathbb{F}_{p}^{n} \mid v \cdot c = 0, \forall c \in C\rbrace\]
\parencite[vgl. ][S. 35f.]{Manz2017}
\end{definition}

Diese Definition mag an die aus der linearen Algebra im Reellen bekannte Definition von Orthogonalität ({\glqq}Rechtwinkligkeit{\grqq}) erinnern, jedoch lässt sich dies auf die hier betrachteten Körper nicht übertragen, unter Anderem, da es auch \textbf{selbstduale} Codes gibt \parencite[vgl. ][S. 36]{Manz2017}.

\begin{note}
Der zu einem $[n, k, d]_{q}$-Code $C$ duale Code $C^{\perp}$ ist ein $[n, n-k, d]_{q}$-Code \parencite[vgl. ][S. 36]{Manz2017}.
\end{note}

Wird der duale Code zu einem dualen Code eines linearen Codes $C$ gebildet, so ist dieser wieder $C$, also gilt:
\[C^{\perp\perp} = C\]

\subsection{Kontroll- und Generatormatrizen}
Da lineare Codes wie gezeigt Vektorräume bilden, ist die Angabe von \textbf{Basen} möglich. Durch die Definition der Dualität von Codes zueinander, können \textbf{Generator-} und \textbf{Kontrollmatrizen} angegeben werden.
\begin{definition}
Sei $C$ ein linearer $[n, k, d]_{q}$-Code und $C^{\perp}$ der duale Code zu $C$. \\
Ferner sei $\big( \langle h_{11}, h_{12}, ..., h_{1n} \rangle, \langle h_{21}, ..., h_{2n} \rangle, ..., \langle h_{(n-k)1}, ..., h_{(n-k)n} \rangle \big)$ eine Basis zu $C^{\perp}$. Dann ist die Matrix 
\[H = \left( \begin{array}{cccc} h_{11} & h_{12} & ... & h_{1n} \\ h_{21} & h_{22} & ... & h_{2n} \\ ... & ... & ... & ... \\ h_{(n-k)1} & h_{(n-k)2} & ... & h_{(n-k)n}\end{array}\right) \] die \textbf{Generatormatrix} von $C^{\perp}$ und \textbf{Kontrollmatrix} von $C$ \parencite[vgl. ][S. 37]{Manz2017}
\end{definition}

Der Zusammenhang zwischen Generator- und Kontrollmatrix ergibt sich daraus, dass über die Generatormatrix des dualen Codes $C^{\perp}$ zu $C$ überprüft werden kann, ob für ein $x \in\mathbb{F}_{q}$ auch $x \in C$ gilt, indem die Skalarprodukte $x \cdot h_i, \forall i \in \lbrace 1, ..., n-k \rbrace$ gebildet werden. Sollte für mindestens eines dieser Produkte $x \cdot h_i \neq 0$ gelten, so ist $x \notin C$ \parencite[vgl. ][S. 37]{Manz2017}. So ließe sich beispielsweise eine Identitätsabbildung $1_{C}(x)$ auf $C$ bilden.

\subsection{Anwendung}
Für den Aufbau eines kryptographischen Verfahrens auf Basis von \textit{Reed-Solomon-Codes} ist neben der Angabe der Codeklasse in Mengenkonstruktionsschreibweise auch die algorithmische Betrachtung des Kodierens und Dekodierens samt Fehlerkorrektur notwendig. Dies wird zunächst exemplarisch anhand von \textit{QR-Codes} und anschließend in allgemeiner Form dargestellt.
\subsubsection{QR-Codes \footnote{Aufgrund des fehlenden Zugriffs auf die spezifizierende ISO-Norm in der aktuellen Fassung bezieht sich diese Arbeit auf den Stand von 2000.}}
\paragraph{Hintergrund}
\textit{\ac{QR}-Codes} sind zweidimensionale Matrix-Codes, die 1994 von einer Tochterfirma des Automobilherstellers Toyota entwickelt wurden, ursprünglich, um die Nachverfolgung von Fahrzeugkomponenten zu gewährleisten \parencite[vgl. ][S. 1]{QROverview2016}. Ziel der Entwicklung war es, ein Barcode-Format zu entwickeln, dass hochperformant und einfach zu scannen ist \parencite[vgl. ][S. 1]{QROverview2016}. Kodierbare Daten sind beispielsweise alphanumerische Zeichenketten, URLs oder Bytedata.
\paragraph{Fehlerkorrektur}
Zwei Arten von Fehlern sind möglich:
\begin{itemize}
\item \textbf{Erasure} -- Ein Symbol, das nicht gescannt oder dekodiert werden kann
\item \textbf{Error} -- Ein Symbol, das falsch dekodiert wurde
\end{itemize}
Durch die Matrixform des Codes führt ein irrtümlich als hell oder dunkel erkanntes Symbol weiterhin zu einem gültigen, wenn auch falschen Codewort. Zur Korrektur dieses falschen Codewortes sind zwei Korrekturworte erforderlich \parencite[vgl. ][S. 33]{ISO18004}. \\\\
Je nach gewählter Qualitätsstufe ist eine verschiedene Anzahl von Korrekturworten erforderlich, die den Tabellen der ISO-Norm 18004 in der jeweils gültigen Fassung entnommen werden können \parencite[vgl. ][S. 35-44]{ISO18004}. Zu jedem Datenwort (bei Bedarf mit Padding-Worten) wird ein Fehlerkorrekturwort berechnet und an die Daten angefügt.
\paragraph{Konstruktion von Fehlerkorrekturworten}
Verwendet wird der Galois-Körper $\mathbb{F}_{2^8}$ mit dem definierenden und auf diesem Körper irreduziblen Polynom $x^8 + x^4 + x^3 + x^2 + 1$. \\\\
Die \textbf{Datencodeworte} bilden nun die Koeffizienten eines Polynoms, wobei das erste Datencodewort die Koeffizienten des Terms mit dem höchsten Grad repräsentieren und das letzte Datencodewort entsprechend die Koeffizienten des Terms mit dem niedrigsten Grad \parencite[vgl. ][S. 45]{ISO18004}. 
\\\\
Dieses Polynom wird nun durch ein für jede QR-Code-Konfiguration in \cite{ISO18004} definiertes \textbf{Generatorpolynom} dividiert. Der dabei entstehende Rest bildet nun die \textbf{Fehlerkorrekturworte}, indem der Koeffizienten des Terms mit dem höchsten Grad das erste Fehlerkorrekturwort und der Koeffizient des Terms mit Grad $0$ das letzte Fehlerkorrekturwort definiert \parencite[vgl. ][S. 45]{ISO18004}. \\\\
Die nun generierten Datencodeworte und Fehlerkorrekturworte ergeben nach einer spezifizierten Anordnung nun die grafische Repräsentation des QR-Codes:
\begin{figure}[h!]
\centering
\includegraphics[scale=0.7]{img/QR-arrangement.PNG}
\caption{Anordnung einzelner Datencodeworte und Fehlerkorrekturcodeworte in einem QR-Code \parencite[][S. 48]{ISO18004}}
\end{figure}
\paragraph{Dekodierung}





 

